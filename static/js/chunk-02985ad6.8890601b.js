(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-02985ad6"],{"5c1d":function(e,n,t){"use strict";t.r(n);var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",[t("Studyrow",{attrs:{studyInfo:e.studyInfo}})],1)},i=[],s=t("5c64"),d={components:{Studyrow:s["a"]},name:"Studyleetcode",data:function(){return{studyInfo:{imsgp:"\n    <p>维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。<br>\n        如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。<br>\n        正向遍历温度列表。对于温度列表中的每个元素 T[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，<br>\n        则比较栈顶元素 prevIndex 对应的温度 T[prevIndex] 和当前温度 T[i]，<br>\n        如果 T[i] > T[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 <br>\n        i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，<br>\n        然后将 i 进栈。为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，<br>\n        即将进栈的 i 对应的 T[i] 一定是 T[prevIndex] 右边第一个比它大的元素，<br>\n        试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。<br>\n        由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。<br>\n    </p>",menulist:["单调栈"],imsg:"每日温度",imsgb:"难度:中等",imsgt:"2021-01-24",heightList:[0,9999],leetCodeLink:"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/",aa:"请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。"}}},created:function(){}},u=d,o=(t("5f14"),t("2877")),c=Object(o["a"])(u,r,i,!1,null,null,null);n["default"]=c.exports},"5f14":function(e,n,t){"use strict";t("ee78")},ee78:function(e,n,t){}}]);
//# sourceMappingURL=chunk-02985ad6.8890601b.js.map